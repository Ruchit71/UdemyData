import unittest
from unittest.mock import AsyncMock, MagicMock
from your_module import service_bus_queue_reader, create_or_update_customer_and_account
import pytest
import json


@pytest.mark.asyncio
class TestServiceBusQueueReader(unittest.TestCase):

    @pytest.fixture(scope="function", name="async_mock_event_hub_logger")
    def async_mock_event_hub_logger(self):
        # Using the fixture for async mock logger
        return MagicMock()

    @pytest.fixture(scope="function", name="mock_service_bus_message")
    def mock_service_bus_message(self):
        # Mock service bus message creation
        def create_service_bus_message(encrypted_body: str, delivery_count: int = 1):
            sb_message = MagicMock(spec=func.ServiceBusMessage)
            sb_message.get_body.return_value = encrypted_body
            sb_message.delivery_count = delivery_count
            return sb_message
        return create_service_bus_message

    @pytest.fixture(scope="function", name="mock_crud_factory")
    def mock_crud_factory(self, mocker):
        # Mock CRUD factory for dependency injection
        mock_crud_factory = MagicMock()
        mock_crud_factory.create = AsyncMock()
        mock_crud_factory.update = AsyncMock()
        mock_crud_factory.delete = AsyncMock()
        mocker.patch("repository.crud.CrudFactory", return_value=mock_crud_factory)
        return mock_crud_factory

    @pytest.mark.asyncio
    async def test_service_bus_queue_reader_success(self, async_mock_event_hub_logger, mock_service_bus_message, mock_crud_factory):
        # Test successful processing of Service Bus Queue message
        encrypted_body = json.dumps([
            {"CUSTOMERID": "123", "ACCOUNTHOLDERNAME": "John Doe", "ENTITYNAME": "ABC Corp", "ACCOUNTNUMBER": "456789"}
        ])
        mock_message = mock_service_bus_message(encrypted_body)

        # Assuming the mocked logger methods are triggered
        await service_bus_queue_reader(mock_message)
        async_mock_event_hub_logger.log.assert_called_once_with("Received 1 messages from pending_accounts queue.")

    @pytest.mark.asyncio
    async def test_service_bus_queue_reader_integrity_conflict(self, async_mock_event_hub_logger, mock_service_bus_message, mock_crud_factory):
        # Test case when an IntegrityConflictException is raised
        encrypted_body = json.dumps([
            {"CUSTOMERID": "123", "ACCOUNTHOLDERNAME": "John Doe", "ENTITYNAME": "ABC Corp", "ACCOUNTNUMBER": "456789"}
        ])
        mock_message = mock_service_bus_message(encrypted_body)

        # Simulate IntegrityConflictException being raised
        mock_crud_factory.create.side_effect = crud.IntegrityConflictException("Event already found")
        
        await service_bus_queue_reader(mock_message)
        
        async_mock_event_hub_logger.log_error.assert_called_once_with("Event already found in database")
        async_mock_event_hub_logger.send_critical_status.assert_called_once_with("Event already found in database")

    @pytest.mark.asyncio
    async def test_service_bus_queue_reader_validation_error(self, async_mock_event_hub_logger, mock_service_bus_message, mock_crud_factory):
        # Test case when a ValidationError is raised
        encrypted_body = json.dumps([
            {"CUSTOMERID": "123", "ACCOUNTHOLDERNAME": "John Doe", "ENTITYNAME": "ABC Corp", "ACCOUNTNUMBER": "invalid_account"}
        ])
        mock_message = mock_service_bus_message(encrypted_body)

        # Simulate ValidationError being raised
        mock_crud_factory.create.side_effect = ValueError("Invalid data")
        
        await service_bus_queue_reader(mock_message)
        
        async_mock_event_hub_logger.log_error.assert_called_once_with("Invalid data")
        async_mock_event_hub_logger.send_critical_status.assert_called_once_with("Invalid data")
