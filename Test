import pytest
from unittest.mock import AsyncMock, MagicMock
from service_bus_function import service_bus_queue_reader, create_or_update_customer_and_account
from helpers.event_hub_logger import EventHubLogger
from helpers import cryptography_service
from repository import crud
from pydantic import ValidationError


@pytest.mark.asyncio
async def test_service_bus_queue_reader_success(mocker):
    # Mock dependencies
    mock_message = MagicMock()
    mock_logger = mocker.patch("service_bus_function.EventHubLogger", autospec=True)
    mock_decrypt = mocker.patch("service_bus_function.cryptography_service.decrypt")
    mock_create_or_update = mocker.patch(
        "service_bus_function.create_or_update_customer_and_account", new_callable=AsyncMock
    )

    # Mock input
    test_message_body = '[{"CUSTOMERID": "123", "ACCOUNTNUMBER": "456"}]'
    mock_message.get_body.return_value = test_message_body.encode()
    mock_decrypt.return_value = test_message_body

    # Run function
    await service_bus_queue_reader(mock_message)

    # Assertions
    mock_logger.assert_called_once_with("process_accounts")
    mock_decrypt.assert_called_once_with(test_message_body)
    mock_create_or_update.assert_called_once_with(
        [{"CUSTOMERID": "123", "ACCOUNTNUMBER": "456"}],
        mock_logger.return_value,
    )
    mock_logger.return_value.send_success_response.assert_called_once_with("Messages processed successfully.")


@pytest.mark.asyncio
async def test_service_bus_queue_reader_validation_error(mocker):
    # Mock dependencies
    mock_message = MagicMock()
    mock_logger = mocker.patch("service_bus_function.EventHubLogger", autospec=True)
    mock_decrypt = mocker.patch("service_bus_function.cryptography_service.decrypt")
    mock_create_or_update = mocker.patch(
        "service_bus_function.create_or_update_customer_and_account", new_callable=AsyncMock
    )

    # Mock input
    test_message_body = '[{"CUSTOMERID": "123", "INVALIDFIELD": "value"}]'
    mock_message.get_body.return_value = test_message_body.encode()
    mock_decrypt.return_value = test_message_body
    mock_create_or_update.side_effect = ValidationError(errors=[], model="")

    # Run function
    await service_bus_queue_reader(mock_message)

    # Assertions
    mock_logger.assert_called_once_with("process_accounts")
    mock_logger.return_value.log_error.assert_called_once()
    mock_logger.return_value.send_critical_status.assert_called_once()
    mock_logger.return_value.log_dead_letter.assert_called_once()


@pytest.mark.asyncio
async def test_service_bus_queue_reader_integrity_conflict(mocker):
    # Mock dependencies
    mock_message = MagicMock()
    mock_logger = mocker.patch("service_bus_function.EventHubLogger", autospec=True)
    mock_decrypt = mocker.patch("service_bus_function.cryptography_service.decrypt")
    mock_create_or_update = mocker.patch(
        "service_bus_function.create_or_update_customer_and_account", new_callable=AsyncMock
    )

    # Mock input
    test_message_body = '[{"CUSTOMERID": "123", "ACCOUNTNUMBER": "456"}]'
    mock_message.get_body.return_value = test_message_body.encode()
    mock_decrypt.return_value = test_message_body
    mock_create_or_update.side_effect = crud.IntegrityConflictException("Conflict!")

    # Run function
    await service_bus_queue_reader(mock_message)

    # Assertions
    mock_logger.assert_called_once_with("process_accounts")
    mock_logger.return_value.log_error.assert_called_once_with(
        "Event already found in database: Conflict!"
    )
    mock_logger.return_value.log_dead_letter.assert_called_once()
    mock_logger.return_value.send_critical_status.assert_called_once()


@pytest.mark.asyncio
async def test_service_bus_queue_reader_generic_error(mocker):
    # Mock dependencies
    mock_message = MagicMock()
    mock_logger = mocker.patch("service_bus_function.EventHubLogger", autospec=True)
    mock_decrypt = mocker.patch("service_bus_function.cryptography_service.decrypt")
    mock_create_or_update = mocker.patch(
        "service_bus_function.create_or_update_customer_and_account", new_callable=AsyncMock
    )

    # Mock input
    test_message_body = '[{"CUSTOMERID": "123", "ACCOUNTNUMBER": "456"}]'
    mock_message.get_body.return_value = test_message_body.encode()
    mock_decrypt.return_value = test_message_body
    mock_create_or_update.side_effect = Exception("Unexpected error")

    # Run function
    await service_bus_queue_reader(mock_message)

    # Assertions
    mock_logger.assert_called_once_with("process_accounts")
    mock_logger.return_value.log_critical.assert_called_once_with(
        "Error: Unexpected error of Type: <class 'Exception'>"
    )
    mock_logger.return_value.log_dead_letter.assert_called_once()
